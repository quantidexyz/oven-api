// This file is auto-generated by @hey-api/openapi-ts

/**
 * The request did not match the expected schema
 */
export type HttpApiDecodeError = {
  issues: Array<Issue>
  message: string
  tag: 'HttpApiDecodeError'
}

/**
 * Represents an error encountered while parsing a value to match the schema
 */
export type Issue = {
  /**
   * The tag identifying the type of parse issue
   */
  tag:
    | 'Pointer'
    | 'Unexpected'
    | 'Missing'
    | 'Composite'
    | 'Refinement'
    | 'Transformation'
    | 'Type'
    | 'Forbidden'
  /**
   * The path to the property where the issue occurred
   */
  path: Array<PropertyKey>
  /**
   * A descriptive message explaining the issue
   */
  message: string
}

export type PropertyKey =
  | string
  | number
  | {
      tag: 'symbol'
      key: string
    }

/**
 * a string to be decoded into a Date
 */
export type _Date = string

/**
 * a string to be decoded into a number
 */
export type NumberFromString = string

export type HealthHealthData = {
  body?: never
  path?: never
  query?: never
  url: '/health'
}

export type HealthHealthErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500:
    | {
        message: string
      }
    | {
        error: string
        timestamp: string
      }
  /**
   * Error
   */
  503:
    | {
        message: string
      }
    | {
        error: string
        timestamp: string
      }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type HealthHealthError = HealthHealthErrors[keyof HealthHealthErrors]

export type HealthHealthResponses = {
  /**
   * Success
   */
  200: {
    status: 'healthy' | 'warning' | 'error'
    timestamp: string
    uptime: number
    version?: string
    environment?: string
    components: {
      database: {
        name: string
        status: 'healthy' | 'warning' | 'error'
        message?: string
        last_checked: string
        response_time?: number
        details?: {
          connected: boolean
          ready_state: number
          host?: string
          database?: string
        }
      }
      jobs: {
        name: string
        status: 'healthy' | 'warning' | 'error'
        message?: string
        last_checked: string
        response_time?: number
        details: {
          jobs: Array<{
            name: string
            status: 'scheduled' | 'running' | 'stuck' | 'overdue'
            next_run_at: string
            locked_at: string
            last_run_at: string
            last_finished_at: string
            repeat_interval: string
            stuck_minutes?: number
            overdue_minutes?: number
          }>
          summary: {
            total: number
            healthy: number
            stuck: number
            overdue: number
          }
        }
      }
      external?: Array<{
        name: string
        status: 'healthy' | 'warning' | 'error'
        message?: string
        details?: {
          [key: string]: unknown
        }
        last_checked: string
        response_time?: number
      }>
    }
    summary: {
      total: number
      healthy: number
      warning: number
      error: number
    }
  }
}

export type HealthHealthResponse =
  HealthHealthResponses[keyof HealthHealthResponses]

export type AuthNonceData = {
  body?: never
  path?: never
  query?: never
  url: '/auth/nonce'
}

export type AuthNonceErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthNonceError = AuthNonceErrors[keyof AuthNonceErrors]

export type AuthNonceResponses = {
  /**
   * a string
   */
  200: string
}

export type AuthNonceResponse = AuthNonceResponses[keyof AuthNonceResponses]

export type AuthVerifyData = {
  body: {
    message: string
    /**
     * `0x${string}`
     * a template literal
     */
    signature: string
  }
  path?: never
  query?: never
  url: '/auth/verify'
}

export type AuthVerifyErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthVerifyError = AuthVerifyErrors[keyof AuthVerifyErrors]

export type AuthVerifyResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
  }
}

export type AuthVerifyResponse = AuthVerifyResponses[keyof AuthVerifyResponses]

export type AuthAddressData = {
  body?: never
  path?: never
  query?: never
  url: '/auth/address'
}

export type AuthAddressErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthAddressError = AuthAddressErrors[keyof AuthAddressErrors]

export type AuthAddressResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
  }
}

export type AuthAddressResponse =
  AuthAddressResponses[keyof AuthAddressResponses]

export type AuthLoginData = {
  body?: never
  path?: never
  query?: never
  url: '/auth/login'
}

export type AuthLoginErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthLoginError = AuthLoginErrors[keyof AuthLoginErrors]

export type AuthLoginResponses = {
  /**
   * Success
   */
  200: {
    url: string
  }
}

export type AuthLoginResponse = AuthLoginResponses[keyof AuthLoginResponses]

export type AuthCallbackData = {
  body?: never
  path?: never
  query?: never
  url: '/auth/callback'
}

export type AuthCallbackErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthCallbackError = AuthCallbackErrors[keyof AuthCallbackErrors]

export type AuthCallbackResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
  }
}

export type AuthCallbackResponse =
  AuthCallbackResponses[keyof AuthCallbackResponses]

export type AuthLogoutData = {
  body?: never
  path?: never
  query?: never
  url: '/auth/logout'
}

export type AuthLogoutErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type AuthLogoutError = AuthLogoutErrors[keyof AuthLogoutErrors]

export type AuthLogoutResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
  }
}

export type AuthLogoutResponse = AuthLogoutResponses[keyof AuthLogoutResponses]

export type MeMeData = {
  body?: never
  path?: never
  query?: never
  url: '/me'
}

export type MeMeErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeMeError = MeMeErrors[keyof MeMeErrors]

export type MeMeResponses = {
  /**
   * Authenticated session response
   */
  200: {
    mongo_id: string
    status: 'authenticated'
    /**
     * UserRole
     * User's role in the system (USER, ADMIN, or SUPER)
     */
    role: 'USER' | 'ADMIN' | 'SUPER' | 'OHARA'
    /**
     * Ethereum/EVM wallet address which has been verified
     */
    verified_address?: string
    /**
     * Twitter/X user ID
     */
    x_user_id?: string
    /**
     * Twitter/X username (handle without @)
     */
    x_username?: string
    /**
     * Twitter/X bio
     */
    x_bio?: string
    /**
     * Twitter/X display name
     */
    x_display_name?: string
    /**
     * URL to Twitter/X profile image
     */
    x_profile_image_url?: string
    /**
     * Referral code for the user
     */
    referral_code: string
    /**
     * Telegram username or handle
     */
    telegram?: string
    /**
     * Discord invite link (discord.gg/... or discord.com/invite/...)
     */
    discord?: string
    /**
     * Personal or project website URL
     */
    website?: string
    /**
     * User profile description or bio
     */
    description?: string
    /**
     * Current signup referral multiplier (1.0 to 2.0)
     */
    signup_ref_multiplier: number
  }
}

export type MeMeResponse = MeMeResponses[keyof MeMeResponses]

export type MeExcludedUsernamesData = {
  body?: never
  path?: never
  query?: never
  url: '/me/excluded-usernames'
}

export type MeExcludedUsernamesErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeExcludedUsernamesError =
  MeExcludedUsernamesErrors[keyof MeExcludedUsernamesErrors]

export type MeExcludedUsernamesResponses = {
  /**
   * ExcludedUsernamesResponse
   * Response containing the list of excluded usernames
   */
  200: {
    /**
     * List of excluded usernames
     */
    excluded_usernames: Array<string>
  }
}

export type MeExcludedUsernamesResponse =
  MeExcludedUsernamesResponses[keyof MeExcludedUsernamesResponses]

export type MeAddExcludedUsernameData = {
  /**
   * AddExcludedUsernameParams
   * Payload for adding a username to the exclusion list
   */
  body: {
    /**
     * Twitter/X username to exclude (without @)
     */
    username: string
  }
  path?: never
  query?: never
  url: '/me/excluded-usernames'
}

export type MeAddExcludedUsernameErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeAddExcludedUsernameError =
  MeAddExcludedUsernameErrors[keyof MeAddExcludedUsernameErrors]

export type MeAddExcludedUsernameResponses = {
  /**
   * ManageExcludedUsernameResponse
   * Response for add/remove excluded username operations
   */
  200: {
    /**
     * Whether the operation was successful
     */
    success: boolean
    /**
     * Success or error message
     */
    message: string
    /**
     * Updated list of excluded usernames
     */
    excluded_usernames: Array<string>
  }
}

export type MeAddExcludedUsernameResponse =
  MeAddExcludedUsernameResponses[keyof MeAddExcludedUsernameResponses]

export type MeRemoveExcludedUsernameData = {
  body?: never
  path: {
    /**
     * Twitter/X username to remove from exclusion list (without @)
     */
    username: string
  }
  query?: never
  url: '/me/excluded-usernames/{username}'
}

export type MeRemoveExcludedUsernameErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeRemoveExcludedUsernameError =
  MeRemoveExcludedUsernameErrors[keyof MeRemoveExcludedUsernameErrors]

export type MeRemoveExcludedUsernameResponses = {
  /**
   * ManageExcludedUsernameResponse
   * Response for add/remove excluded username operations
   */
  200: {
    /**
     * Whether the operation was successful
     */
    success: boolean
    /**
     * Success or error message
     */
    message: string
    /**
     * Updated list of excluded usernames
     */
    excluded_usernames: Array<string>
  }
}

export type MeRemoveExcludedUsernameResponse =
  MeRemoveExcludedUsernameResponses[keyof MeRemoveExcludedUsernameResponses]

export type MeUpdateProfileFieldsData = {
  /**
   * UpdateProfileFieldsParams
   * Payload for updating user profile fields
   */
  body: {
    /**
     * Telegram username or handle
     */
    telegram?: string
    /**
     * Discord invite link (discord.gg/... or discord.com/invite/...)
     */
    discord?: string
    /**
     * Personal or project website URL
     */
    website?: string
    /**
     * User profile description or bio
     */
    description?: string
  }
  path?: never
  query?: never
  url: '/me/profile-fields'
}

export type MeUpdateProfileFieldsErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeUpdateProfileFieldsError =
  MeUpdateProfileFieldsErrors[keyof MeUpdateProfileFieldsErrors]

export type MeUpdateProfileFieldsResponses = {
  /**
   * UpdateProfileFieldsResponse
   * Response for updating profile fields
   */
  200: {
    /**
     * Whether the operation was successful
     */
    success: boolean
    /**
     * Success message
     */
    message: string
    /**
     * Updated profile fields
     */
    profile: {
      telegram?: string
      discord?: string
      website?: string
      description?: string
    }
  }
}

export type MeUpdateProfileFieldsResponse =
  MeUpdateProfileFieldsResponses[keyof MeUpdateProfileFieldsResponses]

export type MeLeaderboardPositionData = {
  body?: never
  path: {
    /**
     * Token contract address
     */
    token_address: string
  }
  query?: {
    /**
     * Optional campaign ID to get position for specific campaign
     */
    campaign_id?: string
  }
  url: '/me/leaderboard-position/{token_address}'
}

export type MeLeaderboardPositionErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type MeLeaderboardPositionError =
  MeLeaderboardPositionErrors[keyof MeLeaderboardPositionErrors]

export type MeLeaderboardPositionResponses = {
  /**
   * GetMyLeaderboardPositionResponse
   * Response containing user's leaderboard position
   */
  200: {
    /**
     * MyLeaderboardPosition
     * User's leaderboard position, null if not in leaderboard
     */
    position: {
      mongo_user_id: string
      mongo_campaign_id: string
      x_user_id: string
      x_username: string
      x_display_name: string
      x_profile_image_url: string
      x_verified: boolean
      points: number
      has_verified_address: boolean
      signup_ref_multiplier?: number
      /**
       * User's current rank in the leaderboard
       */
      rank: number
    }
  }
}

export type MeLeaderboardPositionResponse =
  MeLeaderboardPositionResponses[keyof MeLeaderboardPositionResponses]

export type CampaignStatusData = {
  body?: never
  path?: never
  query: {
    /**
     * Chain ID
     */
    chain_id: string
    /**
     * Token address
     */
    token_address: string
  }
  url: '/campaign/status'
}

export type CampaignStatusErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type CampaignStatusError =
  CampaignStatusErrors[keyof CampaignStatusErrors]

export type CampaignStatusResponses = {
  /**
   * LaunchStatusResponse
   * Response for getting the launch status
   */
  200: {
    /**
     * Whether the token has an inactive campaign in the database
     */
    token_has_inactive_campaign_in_db: boolean
    /**
     * Whether the token has an active campaign in the database
     */
    token_has_active_campaign_in_db: boolean
    /**
     * Whether the token has an active campaign in the blockchain
     */
    token_has_active_campaign_in_blockchain: boolean
    /**
     * Whether the user has an active campaign
     */
    user_has_active_campaign: boolean
    /**
     * Whether the user has a whitelist
     */
    user_has_whiteist: boolean
  }
}

export type CampaignStatusResponse =
  CampaignStatusResponses[keyof CampaignStatusResponses]

export type CampaignActiveCampaignsData = {
  body?: never
  path?: never
  query?: never
  url: '/campaign/active-campaigns'
}

export type CampaignActiveCampaignsErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type CampaignActiveCampaignsError =
  CampaignActiveCampaignsErrors[keyof CampaignActiveCampaignsErrors]

export type CampaignActiveCampaignsResponses = {
  /**
   * Success
   */
  200: Array<{
    /**
     * MongoDB campaign ID
     */
    mongo_id: string
    /**
     * On-chain campaign identifier
     */
    campaign_id?: string
    /**
     * Token symbol
     */
    token_symbol: string
    /**
     * Token contract address
     */
    token_address: string
    /**
     * Campaign owner X username
     */
    x_username: string
    /**
     * Campaign owner X profile image URL
     */
    x_profile_image_url: string
  }>
}

export type CampaignActiveCampaignsResponse =
  CampaignActiveCampaignsResponses[keyof CampaignActiveCampaignsResponses]

export type CampaignSubmitData = {
  /**
   * SubmitCampaignPayload
   * Payload for submitting a leaderboard campaign
   */
  body: {
    /**
     * Blockchain network ID where the leaderboard will be deployed
     */
    chain_id: number
    /**
     * ERC20 token address used for rewards
     */
    token_address: string
    /**
     * Duration of the campaign in days
     */
    campaign_duration: number
    /**
     * Maximum number of top performers who will receive airdrops
     */
    max_airdrop_recipients?: '50' | '100' | '150' | 'INFINITY'
    /**
     * Amount of tokens to deposit as prize pool
     */
    deposit_amount_in_token: string
    /**
     * Optional referrer address for referral rewards
     */
    referrer?: string
  }
  path?: never
  query?: never
  url: '/campaign/submit'
}

export type CampaignSubmitErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type CampaignSubmitError =
  CampaignSubmitErrors[keyof CampaignSubmitErrors]

export type CampaignSubmitResponses = {
  /**
   * SubmitCampaignResponse
   * Response after successfully submitting a campaign
   */
  200: {
    message: string
  }
}

export type CampaignSubmitResponse =
  CampaignSubmitResponses[keyof CampaignSubmitResponses]

export type CampaignVerifyData = {
  /**
   * VerifyCampaignPayload
   * Payload for verifying a leaderboard campaign
   */
  body: {
    /**
     * Blockchain network ID where the leaderboard will be deployed
     */
    chain_id: number
    /**
     * ERC20 token address used for rewards
     */
    token_address: string
  }
  path?: never
  query?: never
  url: '/campaign/verify'
}

export type CampaignVerifyErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type CampaignVerifyError =
  CampaignVerifyErrors[keyof CampaignVerifyErrors]

export type CampaignVerifyResponses = {
  /**
   * VerifyCampaignResponse
   * Response after successfully verifying a campaign
   */
  200: {
    message: string
  }
}

export type CampaignVerifyResponse =
  CampaignVerifyResponses[keyof CampaignVerifyResponses]

export type CampaignData = {
  body?: never
  path: {
    token_address: string
  }
  query?: never
  url: '/campaign/{token_address}'
}

export type CampaignErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type CampaignError = CampaignErrors[keyof CampaignErrors]

export type CampaignResponses = {
  /**
   * Array of campaigns of a leaderboard
   */
  200: {
    latest_campaign: {
      /**
       * ERC20 token address used for rewards
       */
      token_address: string
      /**
       * Symbol of the reward token (e.g., USDT, DAI)
       */
      token_symbol: string
      /**
       * Full name of the reward token
       */
      token_name: string
      /**
       * Number of decimals for the reward token
       */
      token_decimals: number
      /**
       * Original amount of tokens submitted for the campaign
       */
      deposit_amount_in_token: string
      /**
       * Smart contract address of the leaderboard
       */
      vault_address: string
      /**
       * Blockchain network ID where the leaderboard will be deployed
       */
      chain_id: number
      /**
       * Unique on chain identifier for the campaign
       */
      campaign_id?: string
      /**
       * MongoDB ObjectId of the leaderboard
       */
      mongo_owner_id: string
      /**
       * Status of the campaign
       */
      status: 'ACTIVE' | 'INACTIVE' | 'ENDED'
      /**
       * Duration of the campaign in days
       */
      campaign_duration: number
      /**
       * Maximum number of top performers who will receive airdrops
       */
      max_airdrop_recipients?: '50' | '100' | '150' | 'INFINITY'
      created_at: _Date
      updated_at: _Date
      mongo_id: string
    }
    campaigns: Array<{
      /**
       * ERC20 token address used for rewards
       */
      token_address: string
      /**
       * Symbol of the reward token (e.g., USDT, DAI)
       */
      token_symbol: string
      /**
       * Full name of the reward token
       */
      token_name: string
      /**
       * Number of decimals for the reward token
       */
      token_decimals: number
      /**
       * Original amount of tokens submitted for the campaign
       */
      deposit_amount_in_token: string
      /**
       * Smart contract address of the leaderboard
       */
      vault_address: string
      /**
       * Blockchain network ID where the leaderboard will be deployed
       */
      chain_id: number
      /**
       * Unique on chain identifier for the campaign
       */
      campaign_id?: string
      /**
       * MongoDB ObjectId of the leaderboard
       */
      mongo_owner_id: string
      /**
       * Status of the campaign
       */
      status: 'ACTIVE' | 'INACTIVE' | 'ENDED'
      /**
       * Duration of the campaign in days
       */
      campaign_duration: number
      /**
       * Maximum number of top performers who will receive airdrops
       */
      max_airdrop_recipients?: '50' | '100' | '150' | 'INFINITY'
      created_at: _Date
      updated_at: _Date
      mongo_id: string
    }>
  }
}

export type CampaignResponse = CampaignResponses[keyof CampaignResponses]

export type LeaderboardData = {
  body?: never
  path?: never
  query: {
    page: NumberFromString
    limit: NumberFromString
  }
  url: '/leaderboard'
}

export type LeaderboardErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type LeaderboardError = LeaderboardErrors[keyof LeaderboardErrors]

export type LeaderboardResponses = {
  /**
   * LeaderboardsResponse
   * Response format for multiple leaderboards with summary statistics
   */
  200: {
    /**
     * Leaderboard metadata, total active campaigns, total users, total rewards in usd
     */
    metadata: {
      /**
       * Total number of active campaigns
       */
      total_active_campaigns: number
      /**
       * Total number of users participating in all leaderboards
       */
      total_users: number
      /**
       * Total rewards in USD
       */
      total_rewards_in_usd: string
    }
    /**
     * Array of leaderboard summaries with statistics
     */
    data: Array<{
      /**
       * ERC20 token address used for rewards
       */
      token_address: string
      /**
       * Symbol of the reward token (e.g., USDT, DAI)
       */
      token_symbol: string
      /**
       * Full name of the reward token
       */
      token_name: string
      /**
       * Number of decimals for the reward token
       */
      token_decimals: number
      /**
       * URL to Twitter/X profile image
       */
      x_profile_image_url?: string
      /**
       * Twitter/X bio
       */
      x_bio?: string
      /**
       * Twitter/X username (handle without @)
       */
      x_username?: string
      /**
       * Twitter/X display name
       */
      x_display_name?: string
      /**
       * Chain ID of the current campaign
       */
      chain_id: number
      /**
       * Total number of users participating in this leaderboard
       */
      user_count: number
      /**
       * Total points distributed across all users
       */
      points_distributed: number
      /**
       * Duration of the campaign in days
       */
      campaign_duration: number
      /**
       * Unix timestamp for when prizes will be distributed
       */
      prize_deadline_in_unix: number
      /**
       * Total prize pool value in the reward token
       */
      prize_value_in_token: string
      /**
       * Total prize pool value in USD
       */
      prize_value_in_usd: string
    }>
    /**
     * Pagination information for the leaderboard list
     */
    pagination: {
      current_page: number
      total_pages: number
      total_count: number
      limit: number
      has_next_page: boolean
      has_prev_page: boolean
    }
  }
}

export type LeaderboardResponse =
  LeaderboardResponses[keyof LeaderboardResponses]

export type LeaderboardLeaderboardsSummaryData = {
  body?: never
  path?: never
  query?: never
  url: '/leaderboard/summary'
}

export type LeaderboardLeaderboardsSummaryErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type LeaderboardLeaderboardsSummaryError =
  LeaderboardLeaderboardsSummaryErrors[keyof LeaderboardLeaderboardsSummaryErrors]

export type LeaderboardLeaderboardsSummaryResponses = {
  /**
   * LeaderboardsSummaryResponse
   * Summary metadata across all leaderboards
   */
  200: {
    /**
     * Total number of active campaigns
     */
    total_active_campaigns: number
    /**
     * Total number of users participating in all leaderboards
     */
    total_users: number
    /**
     * Total rewards in USD
     */
    total_rewards_in_usd: string
  }
}

export type LeaderboardLeaderboardsSummaryResponse =
  LeaderboardLeaderboardsSummaryResponses[keyof LeaderboardLeaderboardsSummaryResponses]

export type LeaderboardPlatformTopUsersData = {
  body?: never
  path?: never
  query?: {
    limit?: NumberFromString
  }
  url: '/leaderboard/platform-top-users'
}

export type LeaderboardPlatformTopUsersErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type LeaderboardPlatformTopUsersError =
  LeaderboardPlatformTopUsersErrors[keyof LeaderboardPlatformTopUsersErrors]

export type LeaderboardPlatformTopUsersResponses = {
  /**
   * PlatformTopUsersLeaderboard
   * Platform top users leaderboard
   */
  200: {
    data: Array<{
      /**
       * Twitter/X username (handle without @)
       */
      x_username?: string
      /**
       * Twitter/X display name
       */
      x_display_name?: string
      /**
       * URL to Twitter/X profile image
       */
      x_profile_image_url?: string
      /**
       * Twitter/X user ID
       */
      x_user_id?: string
      /**
       * Total points earned by the user in this leaderboard
       */
      points: number
      /**
       * Current signup referral multiplier (1.0 to 2.0)
       */
      signup_ref_multiplier: number
    }>
  }
}

export type LeaderboardPlatformTopUsersResponse =
  LeaderboardPlatformTopUsersResponses[keyof LeaderboardPlatformTopUsersResponses]

export type LeaderboardLeaderboardData = {
  body?: never
  path: {
    /**
     * Token Address
     * The token address of the leaderboard
     */
    token_address: string
    /**
     * Campaign ID
     * The campaign ID of the leaderboard
     */
    campaign_id?: string
  }
  query: {
    page: NumberFromString
    limit: NumberFromString
  }
  url: '/leaderboard/{token_address}/{campaign_id}'
}

export type LeaderboardLeaderboardErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type LeaderboardLeaderboardError =
  LeaderboardLeaderboardErrors[keyof LeaderboardLeaderboardErrors]

export type LeaderboardLeaderboardResponses = {
  /**
   * LeaderboardResponse
   * Response format for a single leaderboard with paginated users
   */
  200: {
    /**
     * Leaderboard metadata excluding user list
     */
    metadata: {
      /**
       * ERC20 token address used for rewards
       */
      token_address: string
      /**
       * Symbol of the reward token (e.g., USDT, DAI)
       */
      token_symbol: string
      /**
       * Full name of the reward token
       */
      token_name: string
      /**
       * Number of decimals for the reward token
       */
      token_decimals: number
      /**
       * Twitter/X username (handle without @)
       */
      x_username?: string
      /**
       * Twitter/X display name
       */
      x_display_name?: string
      /**
       * URL to Twitter/X profile image
       */
      x_profile_image_url?: string
      /**
       * Twitter/X bio
       */
      x_bio?: string
      /**
       * Twitter/X user ID
       */
      x_user_id?: string
      /**
       * Telegram username or handle
       */
      telegram?: string
      /**
       * Discord invite link (discord.gg/... or discord.com/invite/...)
       */
      discord?: string
      /**
       * Personal or project website URL
       */
      website?: string
      /**
       * User profile description or bio
       */
      description?: string
      /**
       * Array of campaigns og the leaderboard
       */
      campaigns: Array<{
        /**
         * ERC20 token address used for rewards
         */
        token_address: string
        /**
         * Symbol of the reward token (e.g., USDT, DAI)
         */
        token_symbol: string
        /**
         * Full name of the reward token
         */
        token_name: string
        /**
         * Number of decimals for the reward token
         */
        token_decimals: number
        /**
         * Original amount of tokens submitted for the campaign
         */
        deposit_amount_in_token: string
        /**
         * Smart contract address of the leaderboard
         */
        vault_address: string
        /**
         * Blockchain network ID where the leaderboard will be deployed
         */
        chain_id: number
        /**
         * Unique on chain identifier for the campaign
         */
        campaign_id?: string
        /**
         * MongoDB ObjectId of the leaderboard
         */
        mongo_owner_id: string
        /**
         * Status of the campaign
         */
        status: 'ACTIVE' | 'INACTIVE' | 'ENDED'
        /**
         * Duration of the campaign in days
         */
        campaign_duration: number
        /**
         * Maximum number of top performers who will receive airdrops
         */
        max_airdrop_recipients?: '50' | '100' | '150' | 'INFINITY'
        created_at: _Date
        updated_at: _Date
        mongo_id: string
      }>
      /**
       * Total number of users participating in this leaderboard
       */
      users_count: number
      /**
       * Total points distributed across all users
       */
      points_distributed: number
      /**
       * Total points distributed across all verified users
       */
      total_verified_points: number
      /**
       * Duration of the campaign in days
       */
      campaign_duration: number
      /**
       * Maximum number of top performers who will receive airdrops
       */
      max_airdrop_recipients?: '50' | '100' | '150' | 'INFINITY'
      /**
       * Unix timestamp for when prizes will be distributed
       */
      prize_deadline_in_unix: number
      /**
       * Total prize pool value in the reward token
       */
      prize_value_in_token: string
      /**
       * Total prize pool value in USD
       */
      prize_value_in_usd: string
    }
    /**
     * Array of users with their X profile data and points
     */
    data: Array<{
      /**
       * Twitter/X user ID
       */
      x_user_id?: string
      /**
       * Twitter/X username (handle without @)
       */
      x_username?: string
      /**
       * Twitter/X display name
       */
      x_display_name?: string
      /**
       * URL to Twitter/X profile image
       */
      x_profile_image_url?: string
      /**
       * Whether the user is verified on Twitter/X
       */
      x_verified?: boolean
      /**
       * MongoDB ObjectId of the user
       */
      mongo_user_id: string
      /**
       * MongoDB ObjectId of the leaderboard campaign
       */
      mongo_campaign_id: string
      /**
       * Total points earned by the user in this leaderboard
       */
      points: number
      has_verified_address: boolean
      /**
       * Current signup referral multiplier (1.0 to 2.0)
       */
      signup_ref_multiplier: number
    }>
    /**
     * Pagination information for the user list
     */
    pagination: {
      current_page: number
      total_pages: number
      total_count: number
      limit: number
      has_next_page: boolean
      has_prev_page: boolean
    }
  }
}

export type LeaderboardLeaderboardResponse =
  LeaderboardLeaderboardResponses[keyof LeaderboardLeaderboardResponses]

export type UserUserData = {
  body?: never
  path: {
    /**
     * Twitter/X user ID
     */
    x_user_id: string
  }
  query?: {
    /**
     * Whether to include smart followers in the response
     */
    include_smart_followers?: 'true' | 'false'
    /**
     * Whether to include smart follower history in the response
     */
    include_smart_follower_history?: 'true' | 'false'
  }
  url: '/user/{x_user_id}'
}

export type UserUserErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type UserUserError = UserUserErrors[keyof UserUserErrors]

export type UserUserResponses = {
  /**
   * Success
   */
  200: {
    /**
     * UserRole
     * User's role in the system (USER, ADMIN, or SUPER)
     */
    role: 'USER' | 'ADMIN' | 'SUPER' | 'OHARA'
    /**
     * List of Twitter/X user IDs of smart followers
     */
    x_smart_follower_ids?: Array<string>
    /**
     * Historic smart follower count changes over time
     */
    smart_follower_history?: Array<{
      /**
       * Unix timestamp when the smart follower count was recorded
       */
      timestamp: number
      /**
       * Smart follower count at this timestamp
       */
      count: number
    }>
    /**
     * Telegram username or handle
     */
    telegram?: string
    /**
     * Discord invite link (discord.gg/... or discord.com/invite/...)
     */
    discord?: string
    /**
     * Personal or project website URL
     */
    website?: string
    /**
     * User profile description or bio
     */
    description?: string
    /**
     * Timestamp of the last profile sync in unix
     */
    x_last_profile_sync_in_unix?: number
    /**
     * Whether the user is verified on Twitter/X
     */
    x_verified?: boolean
    /**
     * Number of verified followers on Twitter/X
     */
    x_verified_followers_count?: number
    /**
     * Number of followers on Twitter/X
     */
    x_followers_count?: number
    /**
     * Number of users following on Twitter/X
     */
    x_following_count?: number
    /**
     * Number of statuses on Twitter/X
     */
    x_statuses_count?: number
    /**
     * Timestamp of the last interaction with a tweet in unix
     */
    x_last_interaction_in_unix?: number
    /**
     * Twitter/X user ID
     */
    x_user_id?: string
    /**
     * Twitter/X username (handle without @)
     */
    x_username?: string
    /**
     * Twitter/X bio
     */
    x_bio?: string
    /**
     * Twitter/X display name
     */
    x_display_name?: string
    /**
     * URL to Twitter/X profile image
     */
    x_profile_image_url?: string
    created_at: _Date
    updated_at: _Date
    /**
     * MongoDB document ID as string
     */
    mongo_id: string
    /**
     * Number of smart followers
     */
    smart_follower_count: number
    /**
     * Total points earned
     */
    total_points_earned: number
    /**
     * Whether the user has a verified EVM address
     */
    has_verified_address: boolean
    /**
     * Current signup referral multiplier (1.0 to 2.0)
     */
    signup_ref_multiplier: number
  }
}

export type UserUserResponse = UserUserResponses[keyof UserUserResponses]

export type UserVerifySignupReferralCodeData = {
  body?: never
  path: {
    /**
     * Referral code for the user
     */
    referral_code: string
  }
  query?: never
  url: '/user/verify-referral-code/{referral_code}'
}

export type UserVerifySignupReferralCodeErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type UserVerifySignupReferralCodeError =
  UserVerifySignupReferralCodeErrors[keyof UserVerifySignupReferralCodeErrors]

export type UserVerifySignupReferralCodeResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
  }
}

export type UserVerifySignupReferralCodeResponse =
  UserVerifySignupReferralCodeResponses[keyof UserVerifySignupReferralCodeResponses]

export type UserAddressData = {
  body?: never
  path: {
    /**
     * Referral code for the user
     */
    referral_code: string
  }
  query?: never
  url: '/user/address/{referral_code}'
}

export type UserAddressErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type UserAddressError = UserAddressErrors[keyof UserAddressErrors]

export type UserAddressResponses = {
  /**
   * Success
   */
  200: {
    /**
     * Verified address for the user
     */
    address: string
  }
}

export type UserAddressResponse =
  UserAddressResponses[keyof UserAddressResponses]

export type UserSyncSmartFollowersData = {
  body?: never
  path: {
    /**
     * Twitter/X user ID
     */
    x_user_id: string
  }
  query?: never
  url: '/user/sync-smart-followers/{x_user_id}'
}

export type UserSyncSmartFollowersErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type UserSyncSmartFollowersError =
  UserSyncSmartFollowersErrors[keyof UserSyncSmartFollowersErrors]

export type UserSyncSmartFollowersResponses = {
  /**
   * Success
   */
  200: {
    /**
     * Whether the smart followers sync was successful
     */
    success: boolean
    /**
     * Message from the sync operation
     */
    message: string
    /**
     * Stats from the sync operation
     */
    stats?: {
      /**
       * Total number of verified followers
       */
      total_verified_followers: number
      /**
       * Number of smart followers added
       */
      smart_followers_added: number
      /**
       * Number of smart followers removed
       */
      smart_followers_removed: number
      /**
       * Number of users created or updated
       */
      users_created_or_updated: number
    }
  }
}

export type UserSyncSmartFollowersResponse =
  UserSyncSmartFollowersResponses[keyof UserSyncSmartFollowersResponses]

export type UserUsersData = {
  body?: never
  path?: never
  query: {
    page: NumberFromString
    limit: NumberFromString
    /**
     * Search users by username or display name
     */
    search?: string
  }
  url: '/user/users'
}

export type UserUsersErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type UserUsersError = UserUsersErrors[keyof UserUsersErrors]

export type UserUsersResponses = {
  /**
   * Success
   */
  200: {
    users: Array<{
      /**
       * MongoDB user ID
       */
      mongo_id: string
      /**
       * X username
       */
      x_username?: string
      /**
       * X display name
       */
      x_display_name?: string
      /**
       * X profile image URL
       */
      x_profile_image_url?: string
      /**
       * User role
       */
      role: string
      /**
       * User creation date (ISO string)
       */
      created_at: string
      /**
       * User last update date (ISO string)
       */
      updated_at: string
    }>
    pagination: {
      current_page: number
      total_pages: number
      total_count: number
      limit: number
      has_next_page: boolean
      has_prev_page: boolean
    }
  }
}

export type UserUsersResponse = UserUsersResponses[keyof UserUsersResponses]

export type SmartfeedSearchData = {
  body?: never
  path?: never
  query: {
    page: NumberFromString
    limit: NumberFromString
    /**
     * Filter by token address (when provided, creates leaderboard feed)
     */
    token_address?: string
    /**
     * Filter by specific campaign ID
     */
    campaign_id?: string
    time_range?: NumberFromString
    /**
     * Comma-separated list of tags to filter by
     */
    tags?: string
    /**
     * Filter tweets with video (true/false)
     */
    has_video?: string
    /**
     * Filter tweets with photos (true/false)
     */
    has_photo?: string
    /**
     * Filter tweets with any media (true/false)
     */
    has_media?: string
    /**
     * Filter tweets from this date (ISO string)
     */
    date_from?: string
    /**
     * Filter tweets until this date (ISO string)
     */
    date_to?: string
    /**
     * Minimum points threshold
     */
    min_points?: NumberFromString
    /**
     * Maximum points threshold
     */
    max_points?: NumberFromString
    /**
     * Comma-separated list of user IDs to filter by
     */
    user_ids?: string
    /**
     * Search term for tweet content
     */
    content_search?: string
    /**
     * Sort field: points, date, engagement
     */
    sort_by: 'points' | 'date' | 'engagement'
    /**
     * Sort order: asc, desc
     */
    sort_order: 'asc' | 'desc'
  }
  url: '/smartfeed/search'
}

export type SmartfeedSearchErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type SmartfeedSearchError =
  SmartfeedSearchErrors[keyof SmartfeedSearchErrors]

export type SmartfeedSearchResponses = {
  /**
   * SmartFeedResponse
   * Response format for smart feed endpoints
   */
  200: {
    /**
     * Array of best performing tweets
     */
    data: Array<{
      /**
       * X (Twitter) tweet ID
       */
      tweet_id: string
      /**
       * Tweet content text
       */
      content: string
      /**
       * Tweet creation date ISO string
       */
      date: string
      /**
       * Direct URL to the tweet
       */
      url: string
      /**
       * Number of likes on the tweet
       */
      like_count: number
      /**
       * Number of retweets
       */
      retweet_count: number
      /**
       * Number of replies
       */
      reply_count: number
      /**
       * Number of quote tweets
       */
      quote_count: number
      /**
       * Number of views (if available)
       */
      view_count: number
      /**
       * Whether the tweet contains media (photos, videos, etc.)
       */
      has_media: boolean
      /**
       * Types of media in the tweet (photo, video, animated)
       */
      media_types: Array<string>
      user: {
        /**
         * Twitter/X user ID
         */
        x_user_id?: string
        /**
         * Twitter/X username (handle without @)
         */
        x_username?: string
        /**
         * Twitter/X display name
         */
        x_display_name?: string
        /**
         * URL to Twitter/X profile image
         */
        x_profile_image_url?: string
        /**
         * Whether the user is verified on Twitter/X
         */
        x_verified?: boolean
      }
      /**
       * Campaign context for all feeds - null if no campaign associated
       */
      campaign_context: {
        /**
         * MongoDB campaign ID
         */
        mongo_campaign_id: string
        token_address: string
        token_symbol: string
        /**
         * User total points in this campaign
         */
        campaign_points: number
      }
      /**
       * Tags associated with this tweet for content moderation and classification
       */
      tags?: Array<string>
    }>
    /**
     * Pagination information for the tweet list
     */
    pagination: {
      current_page: number
      total_pages: number
      total_count: number
      limit: number
      has_next_page: boolean
      has_prev_page: boolean
    }
    /**
     * Smart feed metadata and context
     */
    metadata: {
      /**
       * Total number of tweets analyzed for this feed
       */
      total_tweets_analyzed: number
      /**
       * Time range in hours for tweet analysis
       */
      time_range_hours: number
    }
  }
}

export type SmartfeedSearchResponse =
  SmartfeedSearchResponses[keyof SmartfeedSearchResponses]

export type SmartfeedAddTagData = {
  body: {
    /**
     * SmartFeedTag
     * Tag to add (will be converted to uppercase)
     */
    tag: 'OHARA'
  }
  path: {
    /**
     * User ID who owns the tweet
     */
    user_id: string
    /**
     * Tweet ID to tag
     */
    tweet_id: string
  }
  query?: never
  url: '/smartfeed/{user_id}/{tweet_id}/tags'
}

export type SmartfeedAddTagErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type SmartfeedAddTagError =
  SmartfeedAddTagErrors[keyof SmartfeedAddTagErrors]

export type SmartfeedAddTagResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
    message: string
    tag: string
  }
}

export type SmartfeedAddTagResponse =
  SmartfeedAddTagResponses[keyof SmartfeedAddTagResponses]

export type SmartfeedRemoveTagData = {
  body?: never
  path: {
    /**
     * User ID who owns the tweet
     */
    user_id: string
    /**
     * Tweet ID to untag
     */
    tweet_id: string
    /**
     * SmartFeedTag
     * Tag to remove
     */
    tag: 'OHARA'
  }
  query?: never
  url: '/smartfeed/{user_id}/{tweet_id}/tags/{tag}'
}

export type SmartfeedRemoveTagErrors = {
  /**
   * The request did not match the expected schema
   */
  400:
    | HttpApiDecodeError
    | {
        message: string
      }
  /**
   * Error
   */
  401: {
    message: string
  }
  /**
   * Error
   */
  403: {
    message: string
  }
  /**
   * Error
   */
  404: {
    message: string
  }
  /**
   * Error
   */
  405: {
    message: string
  }
  /**
   * Error
   */
  406: {
    message: string
  }
  /**
   * Error
   */
  408: {
    message: string
  }
  /**
   * Error
   */
  409: {
    message: string
  }
  /**
   * Error
   */
  429: {
    message: string
  }
  /**
   * Error
   */
  500: {
    message: string
  }
  /**
   * Error
   */
  503: {
    message: string
  }
  /**
   * Error
   */
  504: {
    message: string
  }
}

export type SmartfeedRemoveTagError =
  SmartfeedRemoveTagErrors[keyof SmartfeedRemoveTagErrors]

export type SmartfeedRemoveTagResponses = {
  /**
   * Success
   */
  200: {
    success: boolean
    message: string
    tag: string
  }
}

export type SmartfeedRemoveTagResponse =
  SmartfeedRemoveTagResponses[keyof SmartfeedRemoveTagResponses]

export type ClientOptions = {
  baseUrl: `${string}://${string}/api` | (string & {})
}
